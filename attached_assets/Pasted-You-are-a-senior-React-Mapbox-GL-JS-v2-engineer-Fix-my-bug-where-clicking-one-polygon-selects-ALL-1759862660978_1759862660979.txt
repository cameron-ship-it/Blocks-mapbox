You are a senior React + Mapbox GL JS v2 engineer. Fix my bug where clicking one polygon selects ALL polygons. Implement a robust selection system as follows.

Context (Vite + React):
- Token: import.meta.env.VITE_MAPBOX_TOKEN
- Style: import.meta.env.VITE_MAP_STYLE (default light-v11)
- Optional vector tiles template: import.meta.env.VITE_BLOCKS_TILES
- Source id used by my layer: import.meta.env.VITE_BLOCKS_SOURCE (default "blocks")
- Vector source-layer name: import.meta.env.VITE_BLOCKS_SOURCE_LAYER (exact tileset layer name; if unknown we will read it from the clicked feature)
- Fill layer id: import.meta.env.VITE_BLOCKS_LAYER (default "blocks-fill")
- Unique property on each feature: "block_id"

Tasks:

1) Install and import (if not already):
   - npm i mapbox-gl@2.15.0
   - In the component file: 
     import mapboxgl from "mapbox-gl";
     import "mapbox-gl/dist/mapbox-gl.css";

2) Create or replace file: src/components/BlocksMap.tsx with EXACTLY this code:

   -------------------------------------------------
   import React, { useEffect, useRef, useState } from "react";
   import mapboxgl from "mapbox-gl";
   import "mapbox-gl/dist/mapbox-gl.css";

   const MAP_STYLE = import.meta.env.VITE_MAP_STYLE || "mapbox://styles/mapbox/light-v11";
   const LAYER_SOURCE_DEFAULT = import.meta.env.VITE_BLOCKS_SOURCE || "blocks";
   const LAYER_ID_DEFAULT = import.meta.env.VITE_BLOCKS_LAYER || "blocks-fill";

   mapboxgl.accessToken = import.meta.env.VITE_MAPBOX_TOKEN || "";

   type Props = {
     height?: number;
   };

   export default function BlocksMap({ height = 520 }: Props) {
     const mapRef = useRef<mapboxgl.Map | null>(null);
     const containerRef = useRef<HTMLDivElement | null>(null);

     // Keep a canonical set of selected block_id values as strings
     const [selected, setSelected] = useState<Set<string>>(new Set());

     useEffect(() => {
       if (!containerRef.current) return;

       const map = new mapboxgl.Map({
         container: containerRef.current,
         style: MAP_STYLE,
         center: [-73.9819, 40.7681],
         zoom: 11.5,
         cooperativeGestures: true,
       });

       mapRef.current = map;
       map.addControl(new mapboxgl.NavigationControl({ visualizePitch: true }), "top-right");

       map.on("load", () => {
         // If you provide vector tiles via env, add a source with promoteId for stable feature-state
         const tiles = import.meta.env.VITE_BLOCKS_TILES;
         const srcId = LAYER_SOURCE_DEFAULT;

         if (tiles && !map.getSource(srcId)) {
           map.addSource(srcId, {
             type: "vector",
             tiles: [tiles],
             minzoom: 10,
             maxzoom: 16,
             promoteId: "block_id",
           } as any);
         }

         // Determine source-layer to use for this layer. Prefer env, but allow runtime read.
         const envSourceLayer = import.meta.env.VITE_BLOCKS_SOURCE_LAYER;
         const sourceLayer = envSourceLayer && String(envSourceLayer).trim().length > 0 ? envSourceLayer : undefined;

         // Create the fill layer if missing
         if (!map.getLayer(LAYER_ID_DEFAULT)) {
           map.addLayer({
             id: LAYER_ID_DEFAULT,
             type: "fill",
             source: tiles ? srcId : (LAYER_SOURCE_DEFAULT), // if using style’s existing source, ids must match the style
             "source-layer": sourceLayer || undefined,        // if undefined, it must already be set in the style layer
             paint: {
               // Primary path: feature-state highlights selected features
               "fill-color": [
                 "case",
                 ["boolean", ["feature-state", "selected"], false],
                 "#2563eb",
                 "#cbd5e1"
               ],
               "fill-opacity": 0.55,
             },
           } as mapboxgl.FillLayer);
         }

         // Create a thin outline
         const OUTLINE_ID = "blocks-outline";
         if (!map.getLayer(OUTLINE_ID)) {
           const fillLayer: any = map.getLayer(LAYER_ID_DEFAULT);
           map.addLayer({
             id: OUTLINE_ID,
             type: "line",
             source: fillLayer?.source || LAYER_SOURCE_DEFAULT,
             "source-layer": fillLayer?.["source-layer"] || sourceLayer,
             paint: { "line-color": "#475569", "line-width": 0.6 },
           } as mapboxgl.LineLayer);
         }

         // Utility: apply data-driven paint as a fallback when feature-state ids are not available
         const applyPaintFromSelection = () => {
           const arr = Array.from(selected).map(String);
           const selectedLiteral: any = ["literal", arr];
           const inExpr: any = ["in", ["to-string", ["get", "block_id"]], selectedLiteral];

           map.setPaintProperty(LAYER_ID_DEFAULT, "fill-color", [
             "case",
             ["boolean", ["feature-state", "selected"], false], // prefer feature-state when present
             "#2563eb",
             // fallback to property-based selection
             ["case", inExpr, "#2563eb", "#cbd5e1"]
           ]);
         };

         // Click handler toggles selection
         map.on("click", LAYER_ID_DEFAULT, (e) => {
           const f = map.queryRenderedFeatures(e.point, { layers: [LAYER_ID_DEFAULT] })?.[0];
           if (!f) return;

           // Determine source and source-layer from the clicked feature’s layer to avoid mismatches
           const layerInfo: any = f.layer || {};
           const sourceId: string = layerInfo.source || LAYER_SOURCE_DEFAULT;
           const sourceLayerId: string = layerInfo["source-layer"] || sourceLayer || "";

           // Derive a stable id for feature-state if available
           // Prefer feature.id when promoteId is set; otherwise it may be undefined
           const fid = (f as any).id;
           const blockIdProp = String((f.properties as any)?.block_id ?? "");

           // Update our canonical set using block_id property (always present per assumption)
           setSelected((prev) => {
             const next = new Set(prev);
             if (next.has(blockIdProp)) next.delete(blockIdProp); else next.add(blockIdProp);
             // also reflect the change in the map immediately
             // If fid exists, use feature-state for precise toggle on this one feature
             if (fid !== undefined && fid !== null) {
               map.setFeatureState({ source: sourceId, sourceLayer: sourceLayerId, id: fid }, { selected: next.has(blockIdProp) });
             }
             // Always refresh paint so fallback expression stays in sync
             applyPaintFromSelection();
             return next;
           });
         });

         // Ensure cursor feedback
         map.on("mouseenter", LAYER_ID_DEFAULT, () => { map.getCanvas().style.cursor = "pointer"; });
         map.on("mouseleave", LAYER_ID_DEFAULT, () => { map.getCanvas().style.cursor = ""; });

         // Initial paint sync (empty selection)
         applyPaintFromSelection();

         // Debug validators in console to catch common causes of “all selected”
         const fillLayer: any = map.getLayer(LAYER_ID_DEFAULT);
         console.log("DEBUG layer bindings", {
           layerId: LAYER_ID_DEFAULT,
           source: fillLayer?.source,
           sourceLayer: fillLayer?.["source-layer"],
           envSource: LAYER_SOURCE_DEFAULT,
           envSourceLayer,
         });
       });

       return () => {
         map.remove();
         mapRef.current = null;
       };
     }, []);

     return (
       <div
         ref={containerRef}
         style={{ height, width: "100%", borderRadius: 16, border: "1px solid #e5e7eb", overflow: "hidden" }}
       />
     );
   }
   -------------------------------------------------

3) In your wizard page, render this component where the map should appear:
   import BlocksMap from "./components/BlocksMap";
   ...
   <BlocksMap height={520} />

4) Ensure .env contains valid values and use Vite syntax:
   VITE_MAPBOX_TOKEN=YOUR_TOKEN
   VITE_MAP_STYLE=mapbox://styles/mapbox/light-v11
   # If you host your tiles directly, set this; otherwise leave empty to use the style’s own source
   VITE_BLOCKS_TILES=
   VITE_BLOCKS_SOURCE=blocks
   VITE_BLOCKS_SOURCE_LAYER=blocks   # exact tileset layer name
   VITE_BLOCKS_LAYER=blocks-fill

5) Run the app, open it in a NEW browser tab (not the embedded preview), click one polygon, and confirm that only that polygon toggles. 
   If any polygon other than the one clicked toggles, read the console “DEBUG layer bindings” to verify source and source-layer. The clicked feature’s layer must reference the same source id you pass to setFeatureState. This implementation derives the correct ids from the clicked feature, so mismatches are eliminated.

Deliverables:
- Single-click toggles only that polygon.
- No mass-selection.
- Works whether feature-state ids are available or not.
- Uses block_id consistently and safely.