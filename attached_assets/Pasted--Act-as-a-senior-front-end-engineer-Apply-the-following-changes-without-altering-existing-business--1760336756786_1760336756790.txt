“Act as a senior front-end engineer. Apply the following changes without altering existing business logic or data fetch routes except where specified for UX quality. Tech assumptions: React + Mapbox GL JS + Tailwind. If Next is used, keep the app router and file structure. Use feature-state for selection. Use Turf.js for spatial ops. 1) Deliverable: Fix block selection bug. Root cause is global style conditions rather than per-feature state. Requirements: Promote a stable id in the blocks GeoJSON source and drive styles from feature-state. Implement: When adding the source for blocks use promoteId: ‘block_id’ or fallback to ‘GEOID’ if that exists. Example: map.addSource(‘blocks’,{type:‘geojson’,data:blocksGeoJson,promoteId:‘block_id’}). Update layers to style from feature-state. Fill color and outline should switch when feature-state.selected is true. Maintain a Set of selected ids, never mutate the entire GeoJSON for selection. On click of the blocks layer, toggle only that feature with map.setFeatureState({source:‘blocks’,id:fid},{selected:bool}). Preserve selection across setData by reapplying feature-state from the Set after any data refresh. 2) Deliverable: All neighborhoods listed and focusing map on selection. Use the official NYC DCP Neighborhood Tabulation Areas dataset for Manhattan (NTA 2020 or current in repo). Do not hardcode names. Load a neighborhoods GeoJSON source with properties that include a display name (prefer NTAName or neighborhood) and a borough code filter for Manhattan (MN). Build a Neighborhoods module with: A searchable select list, sectioned alphabetically, powered from the neighborhoods GeoJSON properties. A deterministic list is created at init by reading all features where BoroCode or BoroName equals Manhattan. Store a record keyed by neighborhood id with fields {id,name,slug,bbox,geomRef}. When the user selects one or more neighborhoods, compute a combined bbox using Turf. Example flow: const selection = selectedNeighborhoodIds.map(id => featureMap[id]); const unionBbox = bbox(featureCollection(selection)). Call map.fitBounds(unionBbox,{padding:48,animate:true}). Add an onSelect handler that also updates block selection state described in item 3. 3) Deliverable: Default select all blocks inside chosen neighborhoods, allow de-select to exclude, and allow invert. Implement spatial filter pipeline. Keep the blocks source unchanged. On neighborhood selection, compute the set of block feature ids that intersect the chosen neighborhoods using spatial index. Implementation details. Add a lightweight spatial index: Precompute a map from neighborhood id to an array of block ids at app start. If not feasible at build, compute on first selection and cache. Use Turf booleanIntersects(blockGeom, nbhdGeom) or bbox prefilter for speed. Default behavior when at least one neighborhood is selected: mark every intersecting block as selected by setting feature-state.selected = true for each corresponding id. Present two controls above the map: “Include all blocks in selected neighborhoods” and “Invert selection”. Include all sets the selection Set to the full set inside the neighborhoods. Invert replaces the selection Set with all currently visible blocks minus the current selection Set. Also provide “Clear all” which empties the Set. When the user manually clicks a block, toggle only that feature id and update feature-state accordingly. Do not call setData per click. Add a sticky summary footer on the Blocks step showing “Neighborhoods: N • Blocks selected: M” with Back and Next actions. 4) Deliverable: Clean up rest of workflow and create plan for loading initial listings. Workflow cleanup. Create a useStep hook that exposes currentStep, next, back, goTo, and a validate function per step. Steps are Budget, Borough, Neighborhoods, Blocks, Review. Each step is wrapped in a shared AppShell that renders a top nav with a progress stepper and a consistent card layout. Add keyboard focus states and accessible labels. Map interactions: pointer cursor on hover, debounced hover tooltips showing block id and any available stats. Listings plan. Create a ListingsService abstraction with fetchListings(query) that accepts {minRent,maxRent,boroughs,neighborhoodIds,blockIds,page,pageSize}. For now return mock data from a local JSON file seeded in /data/listings.seed.json with fields {id,address,lat,lng,rent,bed,bath,neighborhood,block_id,sourceUrl,images}. Add a simple in-memory cache keyed by a stable hash of the query to avoid refetch thrash during toggles. Show a loading skeleton on the Review step while fetchListings resolves. Render results in a responsive grid and as markers on the map. Placeholders. If no listings are returned, show an EmptyState with guidance to broaden neighborhoods or adjust budget. Technical specifics to implement across modules. A) Selection store. Create a selection module with an in-memory Set for selectedBlockIds and helpers selectAll(ids), clearAll(), invert(allCandidateIds), setSelected(fid,boolean), getSelected(). Ensure that setSelected updates feature-state and keeps the Set in sync. On Mapbox source data refresh, call reapply() to restore feature-state for all selected ids. B) Performance guardrails. Do not recompute Turf intersections on every click. Compute neighborhood-to-block id arrays once and cache. When toggling a single block, only call setFeatureState for that id. When selecting all, batch updates in animation frames to avoid blocking. If the dataset is large, split setFeatureState calls into chunks of 200 per frame. C) Map focus. After neighborhood selection, call fitBounds to the combined bbox. If the user has already manually zoomed, respect their zoom if the new bbox differs by less than 10 percent in area. D) Accessibility. All interactive elements must have role and aria-label attributes. Focus outlines use the Accent color. E) Visual polish. Selected blocks use fill rgba(61,139,255,0.35) and outline #3D8BFF. Default fill rgba(0,0,0,0.08) and outline #BBBBBB. Keep outlines at 2 on selected and 0.6 otherwise. F) Reversible default. Add a toggle labeled “Default is include all blocks in selected neighborhoods” with two modes. Include mode selects all then user deselects to exclude. Exclude mode selects none then user adds blocks to include. Persist the mode in local storage so the setting survives refresh. G) Comprehensive neighborhood list. The UI list is populated by reading the neighborhoods GeoJSON. It must include every Manhattan neighborhood present in the dataset and remain synced when the dataset updates. No hardcoded arrays. Add a search box that filters by name substring. H) QA checks to implement. Clicking one block affects only that block. Selecting one or more neighborhoods filters the block selection universe to those neighborhoods and focuses the map on them. Default selects all blocks within chosen neighborhoods when in Include mode and allows deselection of specific blocks. Invert selection swaps selected and unselected within the current neighborhood scope. The workflow proceeds Budget to Review without dead ends. Review step shows the count of listings and selected blocks. I) Example event handlers and helpers. Use the following patterns verbatim when wiring events. On block click: const f = e.features && e.features[0]; if(!f) return; const fid = String(f.id ?? f.properties?.block_id ?? f.properties?.GEOID); selection.setSelected(fid,!selection.isSelected(fid)). On neighborhood change: const ids = nbhdSelection.getBlockIdsForNeighborhoods(selectedNbhdIds); if(includeMode) selection.selectAll(ids); else selection.clearAll(); reapplyFeatureState(); fitToNeighborhoods(selectedNbhdIds). Reapply selection after data refresh: for(const fid of selection.getSelected()){ map.setFeatureState({source:‘blocks’,id:fid},{selected:true}); }. J) Minimal code edits list for the PR description. 1. Add SelectionStore with Set and helpers. 2. Migrate blocks layer styling to feature-state. 3. Add neighborhoods source, alphabetical searchable list, and bbox focus. 4. Add default include all behavior with invert and clear controls. 5. Add AppShell, progress stepper, and consistent card layout. 6. Add ListingsService with seeded JSON and loading skeleton. 7. Add QA checklist to README and record before and after screenshots. Commit messages. feat(map): per-feature block selection via feature-state. feat(neighborhoods): searchable list, bbox focus, and default block selection. feat(blocks): selection store, include all, invert, clear. feat(workflow): AppShell, stepper, and a11y polish. feat(listings): listings service with skeleton and cache. Run all changes now and keep routes stable.”