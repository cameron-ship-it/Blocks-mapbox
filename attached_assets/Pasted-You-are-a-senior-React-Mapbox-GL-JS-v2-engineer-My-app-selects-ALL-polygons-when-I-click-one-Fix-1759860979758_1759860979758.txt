You are a senior React + Mapbox GL JS v2 engineer. My app selects ALL polygons when I click one. Fix this by verifying IDs and using feature-state correctly, with a robust fallback.

Context (edit only where noted):
- Vector source id: const LAYER_SOURCE = "blocks";        // <— change if different
- Source-layer name: const LAYER_SOURCE_LAYER = "blocks"; // <— EXACT tileset layer name
- Fill layer id: const LAYER_ID = "blocks-fill";
- Outline layer id: const LAYER_LINE_ID = "blocks-outline";
- Unique property on each feature: "block_id"

**Make these changes exactly:**

1) Dependencies (already installed is fine):
   - npm i mapbox-gl@2.15.0
   - In component:
     import mapboxgl from "mapbox-gl";
     import "mapbox-gl/dist/mapbox-gl.css";

2) When adding (or ensuring) the vector source, set promoteId so Mapbox uses block_id as the canonical feature id:
   // If we create the source in code:
   map.addSource(LAYER_SOURCE, {
     type: "vector",
     // If using style-provided source, omit tiles. If using your own tiles, keep them:
     // tiles: [import.meta.env.VITE_BLOCKS_TILES],
     promoteId: "block_id",
     minzoom: 10,
     maxzoom: 16
   });
   // If the source is in the style, ensure in Mapbox Studio that the source has promoteId = block_id.

3) Replace the FILL layer paint with feature-state based styling:
   if (!map.getLayer(LAYER_ID)) {
     map.addLayer({
       id: LAYER_ID,
       type: "fill",
       source: LAYER_SOURCE,
       "source-layer": LAYER_SOURCE_LAYER,
       paint: {
         "fill-color": [
           "case",
           ["boolean", ["feature-state", "selected"], false],
           "#2563eb",
           "#cbd5e1"
         ],
         "fill-opacity": 0.55
       }
     });
   }

   // Keep or recreate outline:
   if (!map.getLayer(LAYER_LINE_ID)) {
     map.addLayer({
       id: LAYER_LINE_ID,
       type: "line",
       source: LAYER_SOURCE,
       "source-layer": LAYER_SOURCE_LAYER,
       paint: { "line-color": "#475569", "line-width": 0.6 }
     });
   }

4) Click toggle handler (REPLACE your existing):
   const selectedIds = new Set<string | number>();

   map.on("click", LAYER_ID, (e) => {
     const f = map.queryRenderedFeatures(e.point, { layers: [LAYER_ID] })?.[0];
     if (!f) return;

     // ID sanity: prefer f.id (from promoteId); fallback to properties.block_id.
     const rawId = (f.id ?? (f.properties && f.properties.block_id));
     if (rawId === undefined || rawId === null) {
       console.warn("No id/block_id on feature. Check LAYER_SOURCE_LAYER and promoteId.");
       return;
     }
     // Normalize id to a stable primitive (string is safest across tiles):
     const id = typeof rawId === "number" ? rawId : String(rawId);

     const key = { source: LAYER_SOURCE, sourceLayer: LAYER_SOURCE_LAYER, id };

     if (selectedIds.has(id)) {
       selectedIds.delete(id);
       map.setFeatureState(key, { selected: false });
     } else {
       selectedIds.add(id);
       map.setFeatureState(key, { selected: true });
     }
   });

5) Clear and remove actions must also unset feature-state (ADD if missing):
   function removeId(id) {
     const norm = typeof id === "number" ? id : String(id);
     map.setFeatureState({ source: LAYER_SOURCE, sourceLayer: LAYER_SOURCE_LAYER, id: norm }, { selected: false });
     selectedIds.delete(norm);
   }
   function clearAll() {
     for (const id of Array.from(selectedIds)) {
       map.setFeatureState({ source: LAYER_SOURCE, sourceLayer: LAYER_SOURCE_LAYER, id }, { selected: false });
     }
     selectedIds.clear();
   }

6) Add a one-time runtime validator to prevent the classic “wrong sourceLayer” bug (ADD right after map load):
   const layers = map.getStyle().layers || [];
   const srcLayerUsedByFill = layers.find(l => l.id === LAYER_ID)?.["source-layer"];
   if (srcLayerUsedByFill !== LAYER_SOURCE_LAYER) {
     console.error("source-layer mismatch:",
       { expected: LAYER_SOURCE_LAYER, actual: srcLayerUsedByFill }
     );
   }

7) **Fallback (only if feature-state still fails, e.g., promoteId not applied by style):**
   - Replace the fill-color with a data-driven expression using string-normalized ids:
     const getIdAsString = ["to-string", ["coalesce", ["id"], ["get", "block_id"]]];
     const selectedLiteral = ["literal", Array.from(selectedIds).map(String)];
     map.setPaintProperty(LAYER_ID, "fill-color", [
       "case",
       ["in", getIdAsString, selectedLiteral],
       "#2563eb",
       "#cbd5e1"
     ]);
   - On every toggle, recompute `selectedLiteral` from the Set and call setPaintProperty again.
   - This avoids “all selected” that occurs when types differ or id is undefined.

8) Finally, log what we actually click (ADD inside the click handler):
   console.log("clicked id:", rawId, "normalized:", id, "layer:", LAYER_SOURCE_LAYER);

Deliverables:
- Use promoteId="block_id" and feature-state with {source, sourceLayer, id}.
- Ensure source-layer EXACTLY matches the tileset layer name.
- Normalize ids to string/number consistently.
- Provide the fallback paint expression if feature-state can’t be used.
- Keep the rest of the wizard unchanged.